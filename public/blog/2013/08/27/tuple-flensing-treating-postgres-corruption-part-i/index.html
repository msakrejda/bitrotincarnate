
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Tuple Flensing I: Treating Postgres Corruption - Bit Rot Incarnate</title>
  <meta name="author" content="Maciek Sakrejda">

  
  <meta name="description" content="Part One: Egress While Postgres is an incredibly robust and defensively-written system,
occasionally one does run into problems with data corruption &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://bitrotincarnate.herokuapp.com/blog/2013/08/27/tuple-flensing-treating-postgres-corruption-part-i">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Bit Rot Incarnate" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=Roboto:400,400italic,700italic,700" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Bit Rot Incarnate</a></h1>
  
    <h2>Postgres et cetera</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:bitrotincarnate.herokuapp.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Tuple Flensing I: Treating Postgres Corruption</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-27T01:25:00-07:00" pubdate data-updated="true">Tue, 2013-08-27 01:25:00 PDT</time>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Part One: Egress</h2>

<p>While Postgres is an incredibly robust and defensively-written system,
occasionally one does run into problems with data corruption. This can
happen due to hardware issues, filesystem or other OS bugs, and
sometimes, yes, even Postgres bugs. However, even when data corruption
does occur, Postgres will generally contain the damage to specific
chunks of data, and manual intervention will let you recover anything
that was not affected.</p>

<p>This is the story of lessons learned from treating an extensive case
of such corruption in the course of my job with the <a href="https://addons.heroku.com/heroku-postgresql">Heroku Postgres</a>
Department of Data. This post describes recognizing the problems and
getting the data out of a corrupt system; the next details restoring it.</p>

<p><small>All data and metadata is mocked out; no customer data was used in the making of this post.</small></p>

<!-- more -->


<h2>Preface</h2>

<p>Josh Williams has <a href="http://blog.endpoint.com/2010/06/tracking-down-database-corruption-with.html">a fantastic post</a>
about treating corruption; Josh&rsquo;s post and tips from my colleagues
(and Postgres contributors) <a href="https://twitter.com/danfarina">Daniel Farina</a>
and <a href="https://twitter.com/sternocera">Peter Geogheghan</a> were instrumental
in helping me wrap my head around all the nuts and bolts relevant here.</p>

<p>Now before we dig in, note that the easiest recovery is one you don&rsquo;t need
to perform at all. So how can you get a pristine copy of your database? Try your
<a href="http://www.postgresql.org/docs/current/static/high-availability.html">standby</a>. There&rsquo;s
a chance that the corruption only affects the primary, because it
never made it into the WAL stream and was not present when the
replica&rsquo;s base backup was taken. Don&rsquo;t have a standby, but have a
<a href="http://www.postgresql.org/docs/current/static/continuous-archiving.html#BACKUP-BASE-BACKUP">base backup</a>
and the required WAL segments? Try making a fresh replica (this can
take some time when the base backup is old, but it&rsquo;s better than the
alternative). You can try a fresh replica in parallel with other
recovery efforts. Validate these with <code>pg_dump</code>, as discussed below,
and then run a dump and restore (again, see below) to ensure that the
corruption is quarantined. <a href="http://tvtropes.org/pmwiki/pmwiki.php/Main/ZombieInfectee">Seriously</a>,
don&rsquo;t delude yourself into thinking it&rsquo;s going to be okay.</p>

<p>This is by far the easiest and safest mechanism for treating
corruption. It&rsquo;s not a panacea, but we&rsquo;ve found it to be unreasonably
effective.</p>

<p>In my case, the existing standby and fresh standbys all failed and
extensive manual recovery was required, but at least it makes for an
interesting story.</p>

<p>If you do need to treat corruption manually, there are a few things
you should keep in mind:</p>

<ul>
<li>Avoid writes: Postgres is in a precarious state; don&rsquo;t tempt fate
by asking it to do more than necessary. In particular, this is a good
point to turn off autovacuum.</li>
<li>Stop Postgres and make a filesystem copy of the full data
directory, ideally to another disk if you suspect the hardware. The
recovery process <em>will</em> involve clobbering data; you want to be
able to start over or cross-reference with the original state of
the system if you run into problems.</li>
<li>Your final step in a corruption recovery should almost always be a
dump and restore via pg_dump. This is the only way to ensure that
you&rsquo;re actually running on a sane system. This can take many hours
for a large database, but if you skip this you might be back at
square one before too long.</li>
<li>The <a href="http://www.postgresql.org/docs/current/static/runtime-config-developer.html">zero_damaged_pages</a>
setting may be an easier way to recover. It doesn&rsquo;t always work, but
it basically does what is outlined here for you.</li>
<li>This ain&rsquo;t Kansas anymore: this is effectively <a href="http://en.wikipedia.org/wiki/Byzantine_fault_tolerance">Byzantine failure</a>
territory. The advice here might work or everything might go
horribly wrong. There are no fool-proof step-by-step
instructions. You&rsquo;re on your own. Furthermore, what&rsquo;s outlined here is a
general-purpose, fairly coarse approach to recovery. If you need to
take a more precise approach or just need someone to blame,
consider hiring a <a href="http://www.postgresql.org/support/professional_support/">Postgres consultancy</a>.</li>
</ul>


<h2>A bad sign</h2>

<p>In this particular case, the problem was almost certainly caused by a
filesystem or hardware issue. Postgres keeps track of the state of
your database via three main sets of data: the heap, where all the
physical data resides; the c(ommit)log, which tracks which
transactions have been committed and which haven&rsquo;t; and the
write-ahead log (WAL), which does all the bookkeeping to ensure
crash-safety and is a key mechanism in Postgres replication.</p>

<p>After intially noticing the corruption, I poked at the affected files
with <code>hexdump</code>, and noticed that one of the <code>clog</code> files, which normally
look like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> hexdump -C pg_clog/0000 | head
</span><span class='line'><span class="go">00000000  40 55 55 55 55 55 55 55  55 55 55 55 55 55 55 55  |@UUUUUUUUUUUUUUU|</span>
</span><span class='line'><span class="go">00000010  55 55 55 55 55 55 55 55  55 55 55 55 55 55 55 55  |UUUUUUUUUUUUUUUU|</span>
</span><span class='line'><span class="go">*</span>
</span><span class='line'><span class="go">000000b0  55 55 55 55 55 55 55 55  55 55 65 55 55 59 55 95  |UUUUUUUUUUeUUYU.|</span>
</span><span class='line'><span class="go">000000c0  55 55 55 55 55 55 59 55  55 55 55 55 55 55 55 55  |UUUUUUYUUUUUUUUU|</span>
</span><span class='line'><span class="go">000000d0  55 95 55 55 55 55 55 55  55 55 55 55 55 55 55 55  |U.UUUUUUUUUUUUUU|</span>
</span><span class='line'><span class="go">000000e0  55 65 55 55 95 55 55 95  55 55 55 55 55 55 59 55  |UeUU.UU.UUUUUUYU|</span>
</span><span class='line'><span class="go">000000f0  55 55 55 55 55 55 55 55  55 55 55 55 55 55 55 55  |UUUUUUUUUUUUUUUU|</span>
</span><span class='line'><span class="go">*</span>
</span><span class='line'><span class="go">00014920  55 55 55 55 55 55 55 55  95 55 55 95 55 55 95 55  |UUUUUUUU.UU.UU.U|</span>
</span></code></pre></td></tr></table></div></figure>


<p>&hellip;looked more like this instead:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> hexdump -C pg_clog/0002 | head -20
</span><span class='line'><span class="go">00000000  40 55 55 55 55 55 55 55  55 55 55 55 55 55 55 55  |@UUUUUUUUUUUUUUU|</span>
</span><span class='line'><span class="go">00000010  55 55 55 55 55 55 55 55  55 55 55 55 55 55 55 55  |UUUUUUUUUUUUUUUU|</span>
</span><span class='line'><span class="go">*</span>
</span><span class='line'><span class="go">00000040  02 00 00 00 00 00 00 00  00 00 00 00 00 00 03 00  |................|</span>
</span><span class='line'><span class="go">00000050  01 00 16 00 07 09 20 ff  7f 0d 00 00 00 00 00 00  |...... .........|</span>
</span><span class='line'><span class="go">00000060  e7 04 00 00 16 00 00 00  00 00 00 00 10 00 00 00  |................|</span>
</span><span class='line'><span class="go">00000070  0c 18 66 bf 01 00 02 00  03 00 00 00 62 00 00 00  |..f.........b...|</span>
</span><span class='line'><span class="go">00000080  98 02 00 00 98 02 00 00  00 00 00 00 da 00 00 00  |................|</span>
</span><span class='line'><span class="go">00000090  a4 01 00 00 04 01 00 03  01 bc 02 00 00 64 08 00  |.............d..|</span>
</span><span class='line'><span class="go">000000a0  00 00 01 10 7b 1f 50 3d  00 65 e1 43 3b 05 dd df  |....{.P=.e.C;...|</span>
</span><span class='line'><span class="go">000000b0  3a 88 c4 e5 a7 0f 04 13  05 dd 5f 0f 04 ff 01 0f  |:........._.....|</span>
</span><span class='line'><span class="go">000000c0  04 36 33 01 00 00 00 00  00 00 00 bc 02 00 00 01  |.63.............|</span>
</span><span class='line'><span class="go">000000d0  00 00 00 01 00 00 00 38  ef 4b 3e 00 00 00 00 00  |.......8.K&gt;.....|</span>
</span><span class='line'><span class="go">000000e0  ee 0d 00 00 c8 06 00 00  04 01 00 03 01 19 00 00  |................|</span>
</span><span class='line'><span class="go">000000f0  00 64 08 00 00 00 01 10  4c 00 00 00 00 61 67 67  |.d......L....agg|</span>
</span><span class='line'><span class="go">00000100  72 65 67 61 74 00 65 5f  64 75 6d 6d 79 00 00 48  |regat.e_dummy..H|</span>
</span><span class='line'><span class="go">00000110  00 00 00 73 65 6c 65 00  63 74 20 24 32 20 2b 20  |...sele.ct $2 + |</span>
</span><span class='line'><span class="go">00000120  00 24 31 00 00 2c 00 00  00 00 74 65 78 74 6c 65  |.$1..,....textle|</span>
</span></code></pre></td></tr></table></div></figure>


<p>Note the ASCII view of the last few lines. If you see anything
human-readable in the <code>clog</code> bitmaps, you should either start buying
lottery tickets, or something very bad has happened.</p>

<p>I originally checked the file after seeing an unexpected error message
that led me to <a href="http://www.postgresql.org/message-id/E1V4LCV-0007AE-8p@wrigleys.postgresql.org">file a Postgres bug</a>.
(The Postgres community, by the way, takes data integrity issues very
seriously and addresses them quickly, so don&rsquo;t hesitate to file a bug
if you think you&rsquo;re running into a legitimate Postgres problem.)</p>

<h2>Trouble with transactions</h2>

<p>The above happened on a replica, and checking the master revealed a
different&mdash;but just as serious&mdash;problem in the logs:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">PG::Error: ERROR: could not access status of transaction 2616655872</span>
</span><span class='line'><span class="go">DETAIL: Could not open file &quot;pg_clog/09BF&quot;: No such file or directory.</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>clog</code> files are bitmaps that live in the <code>pg_clog</code> subdirectory of
your Postgres data directory and track which transactions have been
committed and which have aborted.</p>

<p>You can take a look in the subdirectory and see the various <code>clog</code>
files. If you don&rsquo;t know where your data directory is, you can run the
following Postgres command (this must be run as a Postgres supseruser,
e.g. <code>postgres</code> in most installations):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">maciek# show data_directory;</span>
</span><span class='line'><span class="go">        data_directory        </span>
</span><span class='line'><span class="go">------------------------------</span>
</span><span class='line'><span class="go"> /var/lib/postgresql/9.2/main</span>
</span><span class='line'><span class="go">(1 row)</span>
</span></code></pre></td></tr></table></div></figure>


<p>In that directory, you&rsquo;ll see a number of <code>clog</code> files</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> sudo ls -l /var/lib/postgresql/9.2/main/pg_clog
</span><span class='line'><span class="go">total 1072</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres 262144 Jan  9  2013 0000</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres 262144 Mar 12 11:53 0001</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres 262144 May  8 11:07 0002</span>
</span><span class='line'><span class="go">...</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres 262144 Aug 12 13:41 0011</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres  32768 Aug 13 16:38 0012</span>
</span></code></pre></td></tr></table></div></figure>


<p>These are sequential, and end <em>way</em> before the <code>09BF</code> file that the
error message complained about, so that&rsquo;s not a great sign. So what
can we do? A reasonable assumption might be that everything
referencing transactions in that suspect <code>clog</code> file committed
(actually, that&rsquo;s a terrible assumption, but it&rsquo;s easy to fake
transaction metadata like that, and that&rsquo;s the only way to see the
effects of these alleged transactions, so let&rsquo;s roll with it).  In
order to gin up a hunky-dory <code>clog</code> file, where everything committed, we
can use the trusty <code>dd</code> tool. If you&rsquo;re not familiar with <code>dd</code>, you
can think of it as a bit scalpel for file surgery:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> sudo -u postgres dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/var/lib/postgresql/9.2/main/pg_clog/09BF <span class="nv">bs</span><span class="o">=</span>256k <span class="nv">count</span><span class="o">=</span>1
</span><span class='line'><span class="go">1+0 records out</span>
</span><span class='line'><span class="go">262144 bytes (262 kB) copied, 0.000437751 s, 599 MB/s</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, <code>of</code> is the output <code>clog</code> file you need to generate (dd has a
somewhat unconventional way to pass arguments). Everything else (block
size, block count, and input file&mdash;the handy <code>/dev/zero</code> special file)
can stay the same. Note that you&rsquo;ll probably need to run with sudo as
whatever user owns the other <code>clog</code> files (typically <code>postgres</code>).</p>

<h2>Checking sanity</h2>

<p>So does this fix our problem? One way to check is to re-run the query
that triggered the error in the first place. A more thorough check is
to just run <code>pg_dump</code> to <code>/dev/null</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> pg_dump --verbose &gt;/dev/null my_db
</span></code></pre></td></tr></table></div></figure>


<p>This works because generally, corruption manifests as either
references to bogus transactions (which can be addressed as above), or
some sort of failure when attempting to read a specific set of data
from disk. Postgres organizes data on disk in pages, normally 8192
bytes each. When things get corrupted, problems tend to be
page-aligned&mdash;either a page will be fine, or it&rsquo;s wholy
suspect. Failure to read a page indicates that either the Postgres
page headers are corrupt, or that the data is mangled in such a way as
to cause errors in the per-datatype <code>recv</code> deserialization functions.</p>

<p>Occasionally, a page will be corrupt in such a way as to crash
Postgres when one attempts to read it. This is problematic for
recovery, but not a showstopper&mdash;if we can figure out what pages are
causing crashes, we can surgically excise them.</p>

<p>In either case, pg_dump attempts to read every single live page of
data, so if you make it through that, you&rsquo;re on your way to a
functioning system. Note, however, that this does <em>not</em> validate
the integrity of your indexes: another good reason to always go
through a dump and restore.</p>

<p>Note also that the most pernicious aspects of corruption occur when
none of the above trigger: when bits get shuffled around, but in such
a way as to still represent valid data (just not the data you put
there). Unfortunately, prior to Postgres 9.3&rsquo;s
<a href="http://michael.otacoo.com/postgresql-2/postgres-9-3-feature-highlight-data-checksums/">checksums</a>
feature, there&rsquo;s not much you can do about this. Fortunately, this is
also the least likely problem, as corruption tends to cause chaos and
very few datatypes are resilient to bit scrambling (numeric types
being a notable exception).</p>

<h2>Pages behaving badly</h2>

<p>In this case, the pg_dump still failed with the same error a few more
times. After applying the same remedy a few times to different <code>clog</code>
files, I eventually got to a different error:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">ERROR:  invalid memory alloc request size 2667865904</span>
</span><span class='line'><span class="go">STATEMENT:  COPY public.some_table (col1 int, col2 text) TO stdout</span>
</span></code></pre></td></tr></table></div></figure>


<p>While Postgres supports <a href="http://www.postgresql.org/about/">pretty big</a> rows
and fields, its internal memory management is limited to working with chunks
up to <a href="https://github.com/postgres/postgres/blob/263865a48973767ce8ed7b7788059a38a24a9f37/src/include/utils/memutils.h#L23-L39">1GB</a>.
This request for 2.5GB seems shady. It&rsquo;s likely the metadata about the
size of the value stored on this page is corrupted.</p>

<p>Without significantly more digging, we have to give up on this data as
lost and nuke the page. There are a few other errors you may see that
likely point to corruption:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">pg_dump: SQL command failed</span>
</span><span class='line'><span class="go">pg_dump: Error message from server: ERROR: timestamp out of range</span>
</span><span class='line'><span class="go">pg_dump: The command was: COPY public.table (id, created_at) TO stdout</span>
</span></code></pre></td></tr></table></div></figure>


<p>and</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">pg_dump: SQL command failed</span>
</span><span class='line'><span class="go">pg_dump: Error message from server: ERROR:  invalid page header in block 29 of relation &quot;foo&quot;</span>
</span><span class='line'><span class="go">pg_dump: The command was: COPY public.foo (id, bar) TO stdout</span>
</span></code></pre></td></tr></table></div></figure>


<p>and</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">pg_dump: SQL command failed</span>
</span><span class='line'><span class="go">pg_dump: Error message from server: ERROR: missing chunk number 0 for toast value 118848655 in pg_toast_2619</span>
</span><span class='line'><span class="go">pg_dump: The command was: COPY public.bar (id, baz, quux) TO stdout</span>
</span></code></pre></td></tr></table></div></figure>


<p>So how do we track down the offending page? Fortunately, all rows in
Postgres have a hidden column called <code>ctid</code> that is effectively the
&ldquo;physical&rdquo; row id. If you have the <code>ctid</code>, you can figure out where
the page lives on disk. You can project the <code>ctid</code> just like any other
column:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">maciek=# select ctid, relname from pg_class;</span>
</span><span class='line'><span class="go">  ctid  |                  relname                   </span>
</span><span class='line'><span class="go">--------+--------------------------------------------</span>
</span><span class='line'><span class="go"> (0,1)  | pg_statistic</span>
</span><span class='line'><span class="go"> (0,2)  | pg_type</span>
</span><span class='line'><span class="go"> (0,38) | pg_toast_75018</span>
</span><span class='line'><span class="go"> (0,39) | pg_toast_2619</span>
</span><span class='line'><span class="go"> (0,40) | pg_toast_2619_index</span>
</span><span class='line'><span class="go"> (0,41) | pg_authid_rolname_index</span>
</span><span class='line'><span class="go"> (0,42) | pg_authid_oid_index</span>
</span><span class='line'><span class="go"> (0,43) | pg_attribute_relid_attnam_index</span>
</span><span class='line'><span class="go"> (0,44) | pg_attribute_relid_attnum_index</span>
</span><span class='line'><span class="go">...</span>
</span><span class='line'><span class="go"> (7,73) | pg_toast_11620</span>
</span><span class='line'><span class="go"> (7,77) | pg_toast_11620_index</span>
</span><span class='line'><span class="go">(320 rows)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>ctid</code> values you see are a (page, offset) pair. Chances are,
projecting just the <code>ctid</code> from an affected table is not going to
trigger the memory allocation error we saw above (because Postgres
doesn&rsquo;t have to read any of the affected data).</p>

<p>With that, you can go row by row, projecting every value to see if it
causes problems. Doing this manually can take forever on a good-sized
table, so I wrote a PL/pgSQL function to do it (the <code>FETCH_COUNT</code> trick
from Josh&rsquo;s post could also have helped, but I didn&rsquo;t think of that
at the time):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='sql'><span class='line'><span class="k">CREATE</span> <span class="k">OR</span> <span class="k">REPLACE</span> <span class="k">FUNCTION</span> <span class="k">public</span><span class="p">.</span><span class="n">check_ctids</span><span class="p">(</span><span class="n">t</span> <span class="n">regclass</span><span class="p">)</span>
</span><span class='line'> <span class="k">RETURNS</span> <span class="n">void</span>
</span><span class='line'> <span class="k">LANGUAGE</span> <span class="n">plpgsql</span>
</span><span class='line'><span class="k">AS</span> <span class="err">$</span><span class="k">function</span><span class="err">$</span>
</span><span class='line'><span class="k">DECLARE</span>
</span><span class='line'>  <span class="n">tquoted</span> <span class="nb">text</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ctid</span> <span class="n">tid</span><span class="p">;</span>
</span><span class='line'>  <span class="n">attr</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'><span class="k">BEGIN</span>
</span><span class='line'><span class="k">SELECT</span> <span class="n">quote_ident</span><span class="p">(</span><span class="n">t</span><span class="p">::</span><span class="nb">text</span><span class="p">)</span> <span class="k">INTO</span> <span class="n">tquoted</span><span class="p">;</span>
</span><span class='line'><span class="k">FOR</span> <span class="n">ctid</span> <span class="k">IN</span> <span class="k">EXECUTE</span> <span class="s1">&#39;SELECT ctid FROM &#39;</span> <span class="o">||</span> <span class="n">tquoted</span> <span class="n">LOOP</span>
</span><span class='line'>  <span class="n">RAISE</span> <span class="n">NOTICE</span> <span class="s1">&#39;dumping data for ctid %&#39;</span><span class="p">,</span> <span class="n">ctid</span><span class="p">;</span>
</span><span class='line'>  <span class="k">FOR</span> <span class="n">attr</span> <span class="k">IN</span> <span class="k">EXECUTE</span> <span class="s1">&#39;SELECT quote_ident(attname) FROM pg_attribute WHERE attrelid = $1 and attnum &gt; 0&#39;</span> <span class="k">USING</span> <span class="n">t</span> <span class="n">LOOP</span>
</span><span class='line'>    <span class="k">BEGIN</span>
</span><span class='line'>      <span class="n">PERFORM</span> <span class="s1">&#39;SELECT &#39;</span> <span class="o">||</span> <span class="n">attr</span> <span class="o">||</span> <span class="s1">&#39; FROM &#39;</span> <span class="o">||</span> <span class="n">tquoted</span> <span class="o">||</span> <span class="s1">&#39; WHERE &#39;</span> <span class="o">||</span> <span class="n">tquoted</span> <span class="o">||</span> <span class="s1">&#39;.ctid = check_ctids.ctid&#39;</span><span class="p">;</span>
</span><span class='line'>    <span class="n">EXCEPTION</span>
</span><span class='line'>      <span class="k">WHEN</span> <span class="n">internal_error</span> <span class="k">THEN</span>
</span><span class='line'>        <span class="n">RAISE</span> <span class="n">NOTICE</span> <span class="s1">&#39;data for column % at ctid % is corrupt&#39;</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">ctid</span><span class="p">;</span>
</span><span class='line'>    <span class="k">END</span><span class="p">;</span>
</span><span class='line'>  <span class="k">END</span> <span class="n">LOOP</span><span class="p">;</span>
</span><span class='line'><span class="k">END</span> <span class="n">LOOP</span><span class="p">;</span>
</span><span class='line'><span class="k">END</span><span class="p">;</span>
</span><span class='line'><span class="err">$</span><span class="k">function</span><span class="err">$</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This looks at all the <code>ctid</code>s in the target table, and for each one,
tries to project the values in every column for that row. The columns
are projected one at a time, so that if one exhibits a problem and we
have to purge the row, we can still check the valid ones and save
that data beforehand.</p>

<p>This works for small and medium-sized tables, but takes forever on
anything sizable. I tried to optimize it first by doing a binary
search for bad tuples across <code>ctid</code>s, and then by taking advantage of
the fact that corruption is&mdash;as mentioned above&mdash;typically
page-oriented. In the end, neither of these panned out (for reasons
I&rsquo;ll get to below), but I learned some interesting PL/pgSQL. In any
case, this approach was serviceable for a while and did help me make
progress. The output looks something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">maciek=# select check_ctids(&#39;pg_class&#39;);</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (0,1)</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (0,2)</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (0,38)</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (0,39)</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (0,40)</span>
</span><span class='line'><span class="go">...</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (6,4)</span>
</span><span class='line'><span class="go">NOTICE:  data for column col1 at ctid (6,4) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  data for column col2 at ctid (6,4) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (6,5)</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (6,6)</span>
</span><span class='line'><span class="go">NOTICE:  data for column col1 at ctid (6,6) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  data for column col3 at ctid (6,6) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (6,9)</span>
</span><span class='line'><span class="go">NOTICE:  data for column col1 at ctid (6,9) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  data for column col2 at ctid (6,9) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  data for column col3 at ctid (6,9) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (6,13)</span>
</span><span class='line'><span class="go">NOTICE:  data for column col1 at ctid (6,13) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  data for column col2 at ctid (6,13) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  data for column col3 at ctid (6,13) is corrupt</span>
</span><span class='line'><span class="go">NOTICE:  dumping data for ctid (6,14)</span>
</span><span class='line'><span class="go">...</span>
</span><span class='line'><span class="go"> check_ctids</span>
</span><span class='line'><span class="go">-------------</span>
</span><span class='line'><span class="go"> </span>
</span><span class='line'><span class="go">(1 row)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Trouble on page 6! At this point, you can try to project the other
columns from the affected rows (and any potentially unaffected rows)
so you can save whatever data is still recoverable.</p>

<p>Once we find an affected page, we need to figure out where it lives on
disk. Again, we find what we&rsquo;re looking for in the data directory.
The <code>base</code> subdirectory contains all the &ldquo;actual&rdquo; data (as opposed to
metadata) in your Postgres instance, so this is where we look. The
first level looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> sudo ls -l /var/lib/postgresql/9.2/main/base
</span><span class='line'><span class="go">total 60</span>
</span><span class='line'><span class="go">drwx------ 2 postgres postgres 12288 Jun 30 15:52 1</span>
</span><span class='line'><span class="go">drwx------ 2 postgres postgres  4096 Jun 26  2012 12035</span>
</span><span class='line'><span class="go">drwx------ 2 postgres postgres  4096 Aug  9 15:20 12040</span>
</span><span class='line'><span class="go">drwx------ 2 postgres postgres 12288 Aug 15 16:59 32775</span>
</span><span class='line'><span class="go">drwx------ 2 postgres postgres 20480 Aug 16 17:36 75568</span>
</span><span class='line'><span class="go">drwx------ 2 postgres postgres  4096 Aug 18 02:25 76255</span>
</span><span class='line'><span class="go">drwx------ 2 postgres postgres  4096 Jun 20 21:51 pgsql_tmp</span>
</span></code></pre></td></tr></table></div></figure>


<p>This contains all the different databases (as in <code>CREATE
DATABASE ...</code>) in your Postgres instance. This query can help you
figure out the right subdirectory:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">maciek=# select oid, datname from pg_database;</span>
</span><span class='line'><span class="go">  oid  |     datname      </span>
</span><span class='line'><span class="go">-------+------------------</span>
</span><span class='line'><span class="go">     1 | template1</span>
</span><span class='line'><span class="go"> 12035 | template0</span>
</span><span class='line'><span class="go"> 12040 | postgres</span>
</span><span class='line'><span class="go"> 32775 | maciek</span>
</span><span class='line'><span class="go"> 75568 | observatory_test</span>
</span><span class='line'><span class="go"> 76255 | pqgotest</span>
</span><span class='line'><span class="go">(6 rows)</span>
</span></code></pre></td></tr></table></div></figure>


<p>(<code>oid</code> is another hidden column, a surrogate logical identifier for
many system tables.) In there, you&rsquo;ll see files for your tables and
other aspects of your database:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> sudo ls -l /var/lib/postgresql/9.2/main/base/32775
</span><span class='line'><span class="go">total 6796</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres 163840 Aug 18 01:50 11777</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres  24576 Aug  7 19:33 11777_fsm</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres   8192 Aug  7 19:33 11777_vm</span>
</span><span class='line'><span class="go">...</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres   8192 Aug  7 19:31 75207</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres   8192 Aug  7 19:31 75208</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres      0 Aug 15 16:59 80343</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres      0 Aug 15 16:59 80346</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres    512 Jun  3 14:37 pg_filenode.map</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres 111220 Aug  9 15:21 pg_internal.init</span>
</span><span class='line'><span class="go">-rw------- 1 postgres postgres      4 Jun  3 14:37 PG_VERSION</span>
</span></code></pre></td></tr></table></div></figure>


<p>To find the right table, you might assume you can use the oid again (I
certainly did), but this won&rsquo;t always work. The <code>pg_class</code> system
catalog table can show you the actual file you need (adjust the namespace
as needed):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">maciek=# select relfilenode from pg_class c</span>
</span><span class='line'><span class="go">  inner join pg_namespace ns on c.relnamespace = ns.oid</span>
</span><span class='line'><span class="go">  where relname = &#39;foo&#39; and nspname = &#39;public&#39;;</span>
</span><span class='line'><span class="go"> relfilenode </span>
</span><span class='line'><span class="go">-------------</span>
</span><span class='line'><span class="go">       80343</span>
</span><span class='line'><span class="go">(1 row)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So we have the subdirectory for the database, the file for the table,
and the page and offset from the <code>ctid</code>. Now we need to do some bit
surgery, just as with the <code>clog</code> files above. This is where <code>dd</code>&rsquo;s
&ldquo;addressing&rdquo; feature (via its <code>blocksize</code> and <code>seek</code> parameters) comes
in really handy: <code>dd</code> makes it easy to treat a file as a sequence
of contiguous chunks, and to overwrite just one of these chunks.</p>

<p>Let&rsquo;s go to town:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="gp">$</span> sudo dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">bs</span><span class="o">=</span>8192 <span class="nv">count</span><span class="o">=</span>1 <span class="nv">seek</span><span class="o">=</span>6 <span class="se">\</span>
</span><span class='line'><span class="go">    of=/var/lib/postgresql/9.2/main/base/32775/80343 conv=notrunc</span>
</span><span class='line'><span class="go">1+0 records out</span>
</span><span class='line'><span class="go">262144 bytes (262 kB) copied, 0.000437751 s, 599 MB/s</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here, <code>bs=8192</code> indicates the Postgres page size, <code>count=1</code> means we
overwrite just one page, and <code>seek=6</code> means we want to seek to the 6th
8192-byte page. Again, we use <code>/dev/zero</code> as a source. The very
important <code>conv=notruc</code> means don&rsquo;t truncate the file; just write to
the middle. Remarkably, overwriting a page like this in Postgres is enough
to wipe it out with no ill effects. That&rsquo;s a fantastic property for what
is effectively a massive binary serialization format.</p>

<p>In any case, doing these one-by-one can get tedious (and
error-prone). If you find a lot of these up front, you can even script
the <code>dd</code> invocations:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="k">for </span>bad_page in 89 203 221 227;
</span><span class='line'><span class="k">do</span>
</span><span class='line'><span class="k">  </span>sudo dd <span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>/var/lib/postgresql/9.2/main/base/16385/17889 <span class="se">\</span>
</span><span class='line'>    <span class="nv">bs</span><span class="o">=</span>8192 <span class="nv">seek</span><span class="o">=</span><span class="k">${</span><span class="nv">bad_page</span><span class="k">}</span> <span class="nv">count</span><span class="o">=</span>1 <span class="nv">conv</span><span class="o">=</span>notrunc
</span><span class='line'><span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>


<p>Be extremely careful with this, though&mdash;it&rsquo;s easy to fat-finger your
way to wiping out large swathes of your database.</p>

<h2>Trouble in purgatory</h2>

<p>After a while of making progress like this, I ran into a problem that
I couldn&rsquo;t solve with PL/pgSQL:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='console'><span class='line'><span class="go">LOG:  server process (PID 23544) was terminated by signal 11</span>
</span><span class='line'><span class="go">LOG:  terminating any other active server processes</span>
</span><span class='line'><span class="go">FATAL:  the database system is in recovery mode</span>
</span><span class='line'><span class="go">LOG:  all server processes terminated; reinitializing</span>
</span></code></pre></td></tr></table></div></figure>


<p>Postgres is written defensively, but if its data is scrambled badly
enough, it will still occasionally wig out. With luck, it will recover in
a few seconds and you can continue treating the corruption, but
subsequent attempts to read the affected pages are likely to cause
repeat crashes. This means that any PL/pgSQL functions that rely on
being able to scan a whole table can&rsquo;t really cope with server crashes.</p>

<p>Bash (and shell scripting in general) gets a bad rap&mdash;in many cases,
deservedly so&mdash;but it&rsquo;s still a fantastic way to glue together other
programs. It seemed like an appropriate tool here:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Fill in with everything your own psql invocation needs</span>
</span><span class='line'><span class="nv">psql</span><span class="o">=</span><span class="s2">&quot;psql -U &lt;user&gt; -d &lt;database&gt; -p &lt;port&gt; -h &lt;host&gt;&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">relation</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="p">-</span><span class="s2">&quot;Usage: $0 relation&quot;</span><span class="k">}</span>
</span><span class='line'>
</span><span class='line'><span class="nv">last_page</span><span class="o">=</span>-1
</span><span class='line'><span class="k">for </span>ctid in <span class="k">$(</span><span class="o">&lt;&lt;&lt;</span> <span class="s2">&quot;select ctid from $relation&quot;</span> <span class="nv">$psql</span> -qAt<span class="k">)</span>
</span><span class='line'><span class="k">do</span>
</span><span class='line'><span class="k">    </span><span class="nv">page</span><span class="o">=</span><span class="k">$(</span><span class="nb">echo</span> <span class="nv">$ctid</span> | sed -r <span class="s1">&#39;s/\(([0-9]+),[0-9]+\)/\1/&#39;</span><span class="k">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">[</span> <span class="s2">&quot;$page&quot;</span> -eq <span class="s2">&quot;$last_page&quot;</span> <span class="o">]</span>
</span><span class='line'>    <span class="k">then</span>
</span><span class='line'><span class="k">        continue</span>
</span><span class='line'><span class="k">    fi</span>
</span><span class='line'><span class="k">    </span><span class="nb">echo</span> <span class="s2">&quot;dumping page $page&quot;</span>
</span><span class='line'>    <span class="k">if</span> ! <span class="o">&lt;&lt;&lt;</span> <span class="s2">&quot;select * from $relation where ctid &gt;= &#39;($page,1)&#39; and ctid &lt; &#39;($((page+1)),1)&#39;&quot;</span> <span class="nv">$psql</span> &gt; /dev/null
</span><span class='line'>    <span class="k">then</span>
</span><span class='line'><span class="k">        </span><span class="nb">echo</span> <span class="s2">&quot;Failed on page $page&quot;</span>
</span><span class='line'>        <span class="k">until</span> <span class="o">&lt;&lt;&lt;</span> <span class="s2">&quot;select 1&quot;</span> <span class="nv">$psql</span> &gt;/dev/null; <span class="k">do</span> :; <span class="k">done</span>
</span><span class='line'><span class="k">    fi</span>
</span><span class='line'><span class="k">    </span><span class="nv">last_page</span><span class="o">=</span><span class="s2">&quot;$page&quot;</span>
</span><span class='line'><span class="k">done</span>
</span></code></pre></td></tr></table></div></figure>


<p>This selects all <code>ctid</code>s from a table and then iterates over them.
For each, it dumps all data on a page, and then skips <code>ctid</code>s until
the next page (yes, it would probably be faster to query for only
distinct pages and iterate over just that; this was fast enough).
This prints errors on failed pages (I no longer cared about individual
columns anymore; these few pages were a mess and I couldn&rsquo;t get
anything out), but the really nice part is if that Postgres crashes,
it also just prints an error and waits for it to come back up. This
lets you scan a full table even if Postgres crashes on every page,
and you can apply the page-zapping technique above.</p>

<h2>Victory (sort of)</h2>

<p>After a few more rounds of dealing with a potpourri of the issues above,
I was eventually able to clear out all the errors and get pg_dump to
complete successfully. Only a few dozen pages were affected, but
sorting through everything took hours and was very mentally demanding:
this is where any abstraction provided by your database breaks down,
and you need to start thinking of your data in a completely different
way.</p>

<p>I&rsquo;ve also elided some of the more frustrating inconsistencies and
gotchas in dealing with a system in this state. Occasionally corrupt
pages that I had cleared would come back (autovacuum and other
connections were off, so I&rsquo;m still not sure what caused these),
and in one case a manual <code>COPY</code> worked even though <code>pg_dump</code>&rsquo;s invocation
of the same command failed. Be prepared for weirdness.</p>

<p>Overall, though, Postgres held up admirably: it&rsquo;s very impressive how
well it does in the face of serious data corruption.</p>

<p>Unfortunately, after all this, the dump I got would still not restore
cleanly. I&rsquo;ll go over the (much simpler) steps I had to take to get
things back into Postgres in the next post.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Maciek Sakrejda</span></span>

      








  


<time datetime="2013-08-27T01:25:00-07:00" pubdate data-updated="true">Tue, 2013-08-27 01:25:00 PDT</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/corruption/'>corruption</a>, <a class='category' href='/blog/categories/postgres/'>postgres</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://bitrotincarnate.herokuapp.com/blog/2013/08/27/tuple-flensing-treating-postgres-corruption-part-i/" data-via="deafbybeheading" data-counturl="http://bitrotincarnate.herokuapp.com/blog/2013/08/27/tuple-flensing-treating-postgres-corruption-part-i/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
        <a class="basic-alignment right" href="/blog/2013/09/02/tuple-flensing-treating-postgres-corruption-part-ii/" title="Next Post: Tuple Flensing II: Treating Postgres Corruption">Tuple Flensing II: Treating Postgres Corruption &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>About Me</h1>
  <p>I'm a jack-of-all-trades software engineer, working with Heroku's Department of Data
    to provide <a href="https://addons.heroku.com/heroku-postgresql">Postgres as a service</a>.
    Besides SQL, I currently write Ruby, Go, more bash than I care to admit, and a touch of
    Python here and there.</p>
</section>

<section>
  <h1>On Twitter:</h1>
  <div>
  <p>Check out my <a href="http://twitter.com/deafbybeheading" target="_blank">tweets</a></p>
  <a href="http://twitter.com/deafbybeheading" class="twitter-follow-button" data-show-count="">Follow @deafbybeheading</a>
  </div>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/09/02/tuple-flensing-treating-postgres-corruption-part-ii/">Tuple Flensing II: Treating Postgres Corruption</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/08/27/tuple-flensing-treating-postgres-corruption-part-i/">Tuple Flensing I: Treating Postgres Corruption</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/deafbybeheading">@deafbybeheading</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'deafbybeheading',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Maciek Sakrejda -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
